---
import { config } from "../config";
---

<div
    class="mobile-sticky-cta fixed inset-x-0 bottom-0 z-50 border-t border-gray-200
           bg-white/95 backdrop-blur-sm shadow-[0_-6px_18px_rgba(0,0,0,0.12)]
           translate-y-[110%] transition-transform duration-300 md:hidden"
>
    <div
        class="max-w-[900px] mx-auto px-4 pt-3 pb-[0.75rem] pb-[calc(0.75rem+env(safe-area-inset-bottom))]"
    >
        <div class="text-center text-[11px] font-semibold text-gray-700 mb-1">
            <span class="inline-block align-middle">Protocollo 15</span>
            <span class="mx-1 text-gray-400">â€¢</span>
            <span class="inline-block align-middle">{config.price}</span>
        </div>
        <a
            href={config.ctaUrl}
            class="block w-full bg-primary text-white py-3 px-4 text-sm font-bold rounded-lg
                   text-center border-b-4 border-primary-dark
                   transition-all active:translate-y-0.5 active:border-b-0"
        >
            {config.stickyCtaLabel}
        </a>
    </div>
</div>

<script>
    document.addEventListener("DOMContentLoaded", function () {
        const heroCta = document.getElementById("main-hero-cta");
        const stickyBar = document.querySelector(".mobile-sticky-cta");
        const allCtas = document.querySelectorAll(".js-main-cta");

        if (heroCta && stickyBar && allCtas.length > 0) {
            let isPastHero = false;
            let visibleCtas = new Set();

            const updateStickyVisibility = () => {
                // Show sticky bar ONLY if we are past the hero AND no other CTA is visible
                if (isPastHero && visibleCtas.size === 0) {
                    stickyBar.classList.remove("translate-y-[110%]");
                    stickyBar.classList.add("translate-y-0");
                } else {
                    stickyBar.classList.add("translate-y-[110%]");
                    stickyBar.classList.remove("translate-y-0");
                }
            };

            // Observer for the Hero CTA (to know when to START showing sticky)
            const heroObserver = new IntersectionObserver(
                (entries) => {
                    entries.forEach((entry) => {
                        // If hero CTA is NOT intersecting and we are below it (boundingClientRect.top < 0)
                        // Actually, simpler: if we scroll PAST it.
                        // When it leaves the viewport to the top, entry.boundingClientRect.top should be negative.
                        if (
                            !entry.isIntersecting &&
                            entry.boundingClientRect.top < 0
                        ) {
                            isPastHero = true;
                        } else if (entry.boundingClientRect.top > 0) {
                            // If we are above it (scrolled back up), it's not "past"
                            isPastHero = false;
                        } else if (entry.isIntersecting) {
                            // If it's visible, we are definitely not "past" it in a way that we want the sticky to show
                            // (usually we want sticky to show only after hero CTA is gone)
                            isPastHero = false;
                        }
                        updateStickyVisibility();
                    });
                },
                { threshold: 0 },
            );

            heroObserver.observe(heroCta);

            // Observer for ALL other CTAs (to know when to HIDE sticky)
            const ctaObserver = new IntersectionObserver(
                (entries) => {
                    entries.forEach((entry) => {
                        if (entry.isIntersecting) {
                            visibleCtas.add(entry.target);
                        } else {
                            visibleCtas.delete(entry.target);
                        }
                        updateStickyVisibility();
                    });
                },
                { threshold: 0 },
            );

            allCtas.forEach((cta) => ctaObserver.observe(cta));
        }
    });
</script>
